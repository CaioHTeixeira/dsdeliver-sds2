Spring- Framework java utilizado para o backend.
Postman - Ferramenta para testar as requisições http.

Map<Long, Order> - Coleção de pares chave-valor. //tipo da chave Long e tipo do valor Order.

git init(na pasta do projeto pra iniciar);
git config --global user.email "caioteixeiraaa@gmail.com";
git add .
git commit -m "Project created"
git status; // nessa ordem
git log --oneline; //aparece quantos commits foram feitos e projeto criado.
git remote add origin https://github.com/CaioHTeixeira/dsdeliver-sds2.git; //associar o projeto no seu computador com o do github
git push -u origin main; // enviar o projeto pro meu github.
git branch -M main; // Para trocar o padrão master que é a versão antiga do git para main(versão atual do git).
Arquivos .properties de cada profile do projeto: (serve para configurar seu projeto de maneiras diferentes dependendo do perfil.)
-profile de teste(application-test.properties): vai querer rodar um banco de dados h2 em memória que é criado e destruído toda vez que vc rodar o projeto. É simplesmente um banco de dados de teste.
-Profile dev (application-dev.properties): Ele vai configurar um banco de dados postgres local, pois antes de implantar na nuvem, vc vai querer validadar se esse projeto tá funcionando também com o banco de dados postgres que vai ser o mesmo banco de dados que vamos utilizar na núvem.
-Profile de prod (application-prod.properties): Projeto em produção. Quando ele tá implantado na núvem.

Utilizou-se o Set em vez da lista no Order pois ele não aceita repetição de um produto no mesmo pedido. 
A classe produto é uma entidade gerenciada pela minha ferramenta de ORM, que é o JPA. (@Entity).
@Id definir quem vai ser a chave primária da nossa tabela e como irá se comportar.
@GeneratedValue(strategy = GenerationType.IDENTITY): Para falar que esse Id vai ser um número auto implementável pelo banco.
@ManyToMany ; mapeia aquela tabelinha que faz a associação entre as duas entidades(Product e Order).
@JoinTable(name = "tb_order_product", joinColumns....) ; // Recebe os parametros para falar como construir a tabelinha.
@Service : pois é um objeto da camada de serviço.(nossa classe ProductService vai ser um componente registrado que vai poder ser injetado em outros componentes.
@Autowired: faz a resolução de dependência de forma transparente. 
private ProductRepository repository;
public ProductService(ProductRepository repository) { // esse Autowired seria equivalente a isso; fazer assim é melhor pois não tem tanta dependência igual se //fosse instanciar uma nova classe private ProductRepository repository = new ...; // isso teria um acoplamento forte e não é recomendado. Por isso usa o //Autowired.
	this.repository = repository;
} 

Utiliza o Spring data jpa para ordenar por nome;


create table tb_order (
    id int8 generated by default as identity, 
	address varchar(255),
    latitude float8, 
    longitude float8, 
    moment TIMESTAMP WITHOUT TIME ZONE, 
    status int4, 
    primary key (id)
);

create table tb_order_product (
    order_id int8 not null, 
    product_id int8 not null, 
    primary key (order_id, product_id)
);

create table tb_product (
    id int8 generated by default as identity, 
    name varchar(255),
	price float8,
	description TEXT, 
    image_uri varchar(255),  
    primary key (id)
);

INSERT INTO tb_product (name, price, description, image_Uri) VALUES 
('Pizza de Calabresa', 50.0, 'Pizza calabresa com queijo, molho e massa especial', 'https://github.com/devsuperior/1.png'),
('Pizza Quatro Queijos', 40.0, 'Pizza quatro queijos muito boa', 'https://github.com/devsuperior/2.png'),
('Pizza de Escarola', 60.0, 'Pizza escarola muito boa', 'https://github.com/devsuperior/3.png');

INSERT INTO tb_order (latitude, longitude, moment, status) VALUES 
(213123, 12323, TIMESTAMP WITH TIME ZONE '2021-01-04T11:00:00Z', 0),
(3453453, 3534534, TIMESTAMP WITH TIME ZONE '2021-01-05T11:00:00Z', 1);

INSERT INTO tb_order_product (order_id, product_id) VALUES 
(1 , 1),
(1 , 2),
(2 , 2),
(2 , 3);